/*
 * driver for the spi-tiny-usb adapter - 1.0
 *
 * Copyright (C) 2014 Krystian Duzynski (krystian.duzynski@gmail.com)
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, version 2.
 *
 * Initially based on i2c-tiny-usb project of Till Harbaum (Till@Harbaum.org)
 */
#include <linux/version.h>

#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/slab.h>
#include <linux/types.h>
#include <linux/mutex.h>
#include <linux/workqueue.h>
#include <linux/semaphore.h>
#include <linux/usb.h>
#include <linux/gpio.h>
#include <linux/gpio/driver.h>
#include <linux/spi/spi.h>
//#include <linux/uio_driver.h>
//16ton
#include <linux/delay.h>
#include <linux/iopoll.h>
#include <linux/irq.h>
#include <linux/interrupt.h>
#include <linux/irqdomain.h>
#include <linux/irq.h>
#include <linux/kthread.h>
#include <linux/sched.h>               //task_struct 

DEFINE_SPINLOCK(bm16ton);

#define USB_CMD_WRITE       0
#define USB_CMD_READ        1
#define USB_CMD_GPIO_OUTPUT 2
#define USB_CMD_GPIO_INPUT  3
#define USB_CMD_GPIO_SET    4
#define USB_CMD_GPIO_GET    5

#define FLAGS_BEGIN 1
#define FLAGS_END   2

#define VID 0x16c1
#define PID 0x06db

#define F103_IRQ_POLL_INTERVAL        1 * 1000 * 1000 /* us */    // see above
#define IRQPIN  2
#define F103_NUM_GPIOS  2

const char *gpio_names[] = { "led", "irq" };

struct f103_gpio_irq {
	struct irq_domain *irq_domain;
	struct mutex      irq_lock;
	int               virq[F103_NUM_GPIOS];
	u16               irq_mask;
};

/* Structure to hold all of our device specific stuff */
struct spi_tiny_usb {
	struct usb_device *usb_dev;	/* the usb device for this device */
	struct usb_interface *interface;	/* the interface for this device */
	struct urb *urb;	/* urb for usb interrupt transfer */
	char *urbBuffer;	/* urb incoming data buffer */
	struct spi_master *master;	/* spi master related things */
	struct spi_device *spidev;	/* spi device related things */
	struct spi_board_info info;	/* board info for spidev module */
//	struct uio_info *uio;	/* Userspace IO for interrupt management */

	struct mutex usb_bus_lock;

	struct f103_gpio_irq irq_chip;
	struct work_struct irq_work;

	struct gpio_chip gpio_chip;	/* gpio related things */
	u8 gpio_states[2];
	int old_value;
    uint8_t                  gpio_num;                          // number of pins used as GPIOs
    uint8_t                  gpio_mask;                         // configuratoin mask defines IN/OUT pins
    uint8_t                  gpio_io_data;                      // current value of CH341 I/O register
    struct task_struct *     gpio_thread;                       // GPIO poll thread
    struct f103_pin_config* gpio_pins   [F103_NUM_GPIOS]; // pin configurations (gpio_num elements)
    uint8_t                  gpio_bits   [F103_NUM_GPIOS]; // bit of I/O data byte (gpio_num elements)
    uint8_t                  gpio_values [F103_NUM_GPIOS]; // current values (gpio_num elements)
    char*                    gpio_names  [F103_NUM_GPIOS]; // pin names  (gpio_num elements)
    int                      gpio_irq_map[F103_NUM_GPIOS]; // GPIO to IRQ map (gpio_num elements)
	int irq_poll_interval;

    struct irq_chip   irq;                                // chip descriptor for IRQs
    uint8_t           irq_num;                            // number of pins with IRQs
    int               irq_base;                           // base IRQ allocated
    struct irq_desc*  irq_descs    [F103_NUM_GPIOS]; // IRQ descriptors used (irq_num elements)
    int               irq_types    [F103_NUM_GPIOS]; // IRQ types (irq_num elements)
    bool              irq_enabled  [F103_NUM_GPIOS]; // IRQ enabled flag (irq_num elements)
    int               irq_gpio_map [F103_NUM_GPIOS]; // IRQ to GPIO pin map (irq_num elements)
    int               irq_hw;                             // IRQ for GPIO with hardware IRQ (default -1)

	u8 *usb_xfer;
};

// static uint poll_period = F103_IRQ_POLL_INTERVAL;       // module parameter poll period
static void spi_tiny_usb_urb_complete(struct urb *urb);

static void spi_tiny_usb_free(struct spi_tiny_usb *priv)
{
	usb_put_dev(priv->usb_dev);
	kfree(priv);
}

static int spi_tiny_usb_freqtodiv(int freq)
{
	int div = 48 * 1000 * 1000 / freq;
	int i, divVal = 0;
	for (i = 2; i <= 256; i *= 2, divVal++)
		if (i >= div)
			break;
	return divVal;
}

static int
usb_read(struct spi_tiny_usb *dev, int cmd, int value, int index, void *data, int len);
static int
usb_write(struct spi_tiny_usb *dev, int cmd, int value, int index, void *data, int len);

/*-------begin irq layer------------------------*/
static irqreturn_t gpio_irq_handler(int irq,void *dev_id)
{
  /* Raise the softirq */
//  raise_softirq( MPSSE_SOFT_IRQ );
//	return dev->irq_chip.virq[pin];

  return IRQ_HANDLED;
}

void f103_irq_enable_disable (struct irq_data *data, bool enable)
{
	struct f103_gpio_irq *irq_dev = irq_data_get_irq_chip_data(data);
	struct spi_tiny_usb *dev
		= container_of(irq_dev, struct spi_tiny_usb, irq_chip);
//    struct spi_tiny_usb *dev;
    int irq;

    // calculate local IRQ
    irq = data->irq - dev->irq_base;

    // valid IRQ is in range 0 ... f103_dev->irq_num-1, invalid IRQ is -1
    if (irq < 0 || irq >= dev->irq_num) return;

    // enable local IRQ
    dev->irq_enabled[irq] = enable;

    dev_info(&dev->usb_dev->dev, "irq=%d enabled=%d",
              data->irq, dev->irq_enabled[irq] ? 1 : 0);
}

void f103_irq_enable (struct irq_data *data)
{
    f103_irq_enable_disable (data, true);
}

void f103_irq_disable (struct irq_data *data)
{
    f103_irq_enable_disable (data, false);
}

int f103_gpio_to_irq (struct gpio_chip *chip, unsigned offset)
{
    #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,5,0)
    struct spi_tiny_usb* dev = (struct spi_tiny_usb*)gpiochip_get_data(chip);
    #else
    struct spi_tiny_usb* dev = container_of(chip, struct spi_tiny_usb, gpio);
    #endif
    int irq;


    // valid IRQ is in range 0 ... ch341_dev->irq_num, invalid IRQ is -1
    irq = dev->irq_gpio_map[offset];
	irq = (irq >= 0 ? dev->irq_base + irq : 0);
//	irq = gpio_to_irq(offset);
//    irq = (irq >= 0 ? dev->irq_base + irq : 0);

    dev_dbg(&dev->usb_dev->dev, "gpio=%d irq=%d", offset, irq);

    return irq;
}

static void f103_gpio_irq_mask(struct irq_data *data)
{
	struct f103_gpio_irq *irq_dev = irq_data_get_irq_chip_data(data);
	struct spi_tiny_usb *dev
		= container_of(irq_dev, struct spi_tiny_usb, irq_chip);

	dev_dbg(&dev->usb_dev->dev, "irq mask %lu", data->hwirq);
	irq_dev->irq_mask &= ~(1 << data->hwirq);
}

static void f103_gpio_irq_unmask(struct irq_data *data)
{
	struct f103_gpio_irq *irq_dev = irq_data_get_irq_chip_data(data);
	struct spi_tiny_usb *dev
		= container_of(irq_dev, struct spi_tiny_usb, irq_chip);

	dev_dbg(&dev->usb_dev->dev, "irq unmask %lu", data->hwirq);
	irq_dev->irq_mask |= 1 << data->hwirq;
}

static int f103_gpio_irq_set_type(struct irq_data *data, unsigned int type)
{
	struct spi_tiny_usb *dev = irq_data_get_irq_chip_data(data);
	struct spi_tiny_usb *irq_dev = irq_data_get_irq_chip_data(data);
    int irq;

	irq = data->irq - dev->irq_base;
//	int irq;
//	irq = dev->irq;
	irq_dev->irq_types[irq] = type;
	return 0;
}

static void f103_gpio_irq_bus_lock(struct irq_data *data)
{
	struct f103_gpio_irq *irq_dev = irq_data_get_irq_chip_data(data);
	mutex_lock(&irq_dev->irq_lock);
}

static void f103_gpio_irq_bus_unlock(struct irq_data *data)
{
	struct f103_gpio_irq *irq_dev = irq_data_get_irq_chip_data(data);
	mutex_unlock(&irq_dev->irq_lock);
}

struct f103_pin_config {
    uint8_t pin;    // pin number of CH341 chip
    uint8_t mode;   // GPIO mode
    char*   name;   // GPIO name
    bool    hwirq;  // connected to hardware interrupt (only one pin can have true)
};

struct f103_pin_config f103_board_config[1] =
{
    // pin  GPIO mode           GPIO name   hwirq
    {   1, 	    1  , "gpio1"    , 0 }, // used as input
};


static struct irq_chip f103_gpio_irq_chip = {
	.name                = "gpio-f103",
	.irq_mask            = f103_gpio_irq_mask,
	.irq_unmask          = f103_gpio_irq_unmask,
	.irq_enable          = f103_irq_enable,
	.irq_disable  		 = f103_irq_disable,
	.irq_set_type        = f103_gpio_irq_set_type,
	.irq_bus_lock        = f103_gpio_irq_bus_lock,
	.irq_bus_sync_unlock = f103_gpio_irq_bus_unlock,
};

static int f103_gpio_irq_map(struct irq_domain *domain, unsigned int irq,
                               irq_hw_number_t hwirq)
{
	irq_set_chip_data(irq, domain->host_data);
	irq_set_chip(irq, &f103_gpio_irq_chip);
	irq_set_chip_and_handler(irq, &f103_gpio_irq_chip, handle_simple_irq);
//	irq_set_chip_and_handler(irq, &f103_gpio_irq_chip, generic_handle_irq);
	irq_set_noprobe(irq);
	return 0;
}

static const struct irq_domain_ops f103_gpio_irq_domain_ops = {
	.map = f103_gpio_irq_map,
};

//static void f103_gpio_irq_remove(struct f103_device *dev);
static int spi_tiny_usb_gpio_get(struct gpio_chip *chip, unsigned offset);

static void f103_read_gpios(struct work_struct *work)
{

//	struct spi_tiny_usb *priv;
	struct spi_tiny_usb *dev = container_of(work,
	                                         struct spi_tiny_usb,
	                                         irq_work);


	struct f103_gpio_irq *irq_dev = &dev->irq_chip;
//	struct spi_tiny_usb *priv = dev_get_drvdata(&dev);

	unsigned long flags;
    uint8_t oldio;
    uint8_t new_value;
//	int result;

//	old_value = 1;
	oldio = dev->old_value;
//    oldio = gpio_get_value(IRQPIN);

//	dev_info(&dev->usb_dev->dev, "read gpios saved state b4 init state pin4 %d", oldio);
//	dev_dbg(&dev->usb_dev->dev, "read gpio saved state b4 init state pin4 %d", oldio);
//	dev_info(&dev->usb_dev->dev, "read gpios b4 init state pin4 %d", gpio_get_value(IRQPIN));
//	dev_dbg(&dev->usb_dev->dev, "read gpios b4 init state pin4 %d", gpio_get_value(IRQPIN));
	printk(KERN_INFO "read gpios b4 init state pin4 %d", oldio);

//	gpio_request(IRQPIN,"IRQPIN");
//    gpio_direction_input(IRQPIN);
//	gpio_export(IRQPIN, true);
//priv->gpio_chip.base

//	dev_info(&dev->usb_dev->dev, "read gpios saved state after init state pin4 %d", oldio);
//	dev_dbg(&dev->usb_dev->dev, "read gpio saved state after init state pin4 %d", oldio);
//	dev_dbg(&dev->usb_dev->dev, "read gpio after init state pin4 %d", gpio_get_value(IRQPIN));
	printk(KERN_INFO "read gpio after init state pin4 %d", gpio_get_value(IRQPIN));


    //16ton
	printk(KERN_INFO  "start read gpios");

loop:

//	recv_pipe = usb_rcvctrlpipe(dev->udev, 0);
//	mutex_lock(&dev->usb_bus_lock);

    new_value = gpio_get_value(IRQPIN);
			


	if (oldio == new_value) {
//			mutex_lock(&irq_dev->irq_lock);
			dev_dbg(&dev->usb_dev->dev, "issue irq on %d", IRQPIN);
//			local_irq_save(flags);
			spin_lock_irq(&bm16ton);
//			generic_handle_irq(dev->irq_chip.virq[IRQPIN]);
// old 			handle_simple_irq (dev->irq_base+irq, dev->irq_descs[irq]);
//			handle_simple_irq (dev->irq_descs[IRQPIN]);
//			generic_handle_domain_irq(&irq_dev->irq_domain, -1);
			handle_simple_irq (dev->irq_descs[IRQPIN]);
			dev_dbg(&dev->usb_dev->dev, "new irq pinstate %d", gpio_get_value(IRQPIN));
			spin_unlock_irq(&bm16ton);
//			local_irq_restore(flags);
//			mutex_unlock(&irq_dev->irq_lock);
	}

	if (dev->irq_poll_interval < 0)
		return;

	usleep_range(dev->irq_poll_interval, dev->irq_poll_interval + 20);
	goto loop;

//error2:
//	return;
}

static int f103_gpio_irq_probe(struct spi_tiny_usb *dev)
{
	struct f103_gpio_irq *irq_dev = &dev->irq_chip;
	struct spi_tiny_usb *priv;
	int i;
//	int result;

	priv = kzalloc(sizeof(struct spi_tiny_usb), GFP_KERNEL);
	if (!priv)
		return -ENOMEM;

	dev->irq_base    = 0;

	mutex_init(&irq_dev->irq_lock);

	irq_dev->irq_domain = irq_domain_add_linear(
		dev->usb_dev->dev.of_node, F103_NUM_GPIOS,
		&f103_gpio_irq_domain_ops, irq_dev);

	if (!irq_dev->irq_domain) {
		dev_err(&dev->usb_dev->dev, "failed to register IRQ domain");
		return -ENOMEM;
	}

	irq_dev->irq_mask = 0;
	for (i = 0; i < F103_NUM_GPIOS; ++i) {
		irq_dev->virq[i] =
			irq_create_mapping(irq_dev->irq_domain, i);
		dev_dbg(&dev->usb_dev->dev, "created virtual irq %d",
		        irq_dev->virq[i]);
	}

 //   gpio_request(dev->gpio_chip.base + 1, f103_board_config[2].name);
 //   gpio_export (dev->gpio_chip.base + 1, f103_board_config[2].pin);

//    dev->gpio_irq_map[dev->gpio_num] = dev->irq_num;
 //   dev->irq_gpio_map[dev->irq_num]  = dev->gpio_num;
//	result = irq_alloc_descs(-1, 0, dev->irq_num, 0);
//	dev->irq_base = result;

	dev->old_value = gpio_get_value(IRQPIN);
		
	dev_dbg(&dev->usb_dev->dev, "irq probe gpios init state %d", dev->old_value);

	INIT_WORK(&dev->irq_work, f103_read_gpios);
	schedule_work(&dev->irq_work);

	return 0;
}

static void f103_gpio_irq_remove(struct spi_tiny_usb *dev)
{
	int i = 0;

	if (!dev->irq_chip.irq_domain)
		return;

	for (i = 0; i < F103_NUM_GPIOS; ++i) {
		irq_dispose_mapping(dev->irq_chip.virq[i]);
	}

	irq_domain_remove(dev->irq_chip.irq_domain);
}


/* ----- begin of spi layer ---------------------------------------------- */

static int spi_tiny_usb_xfer_one(struct spi_master *master, struct spi_message *m)
{
	struct spi_tiny_usb *priv = spi_master_get_devdata(master);
	struct spi_transfer *t;
	int spi_flags;
	int ret = 0;

	m->actual_length = 0;

	spi_flags = FLAGS_BEGIN;
	list_for_each_entry(t, &m->transfers, transfer_list) {
		if (list_is_last(&t->transfer_list, &m->transfers))
			spi_flags |= FLAGS_END;

		spi_flags |= spi_tiny_usb_freqtodiv(t->speed_hz) << 2;

		dev_dbg(&master->dev,
			"tx: %p rx: %p len: %d speed: %d flags: %d delay: %d\n", t->tx_buf,
			t->rx_buf, t->len, t->speed_hz, spi_flags, t->delay.value);

		if (t->cs_change)
			spi_flags |= FLAGS_END;

		if (t->tx_buf) {
			ret = usb_write(priv, 0, 0, spi_flags, (void *)t->tx_buf, t->len);
			if (ret < 0)
				break;
		} else {
			void *txbuf = kmalloc(t->len, GFP_KERNEL);
			memset(txbuf, 0x00, t->len);
			if (!txbuf) {
				ret = -ENOMEM;
				break;
			}
			ret = usb_write(priv, 0, 0, spi_flags, txbuf, t->len);
			kfree(txbuf);
			if (ret < 0)
				break;
		}

		if (t->rx_buf) {
			ret = usb_read(priv, 1, 0, 0, t->rx_buf, t->len);
			if (ret < 0)
				break;
		}
		// spin_lock_irqsave(&ebu_lock, flags);
		// ret = spi_tiny_usb_xfer(m->spi, t, spi_flags);
		// spin_unlock_irqrestore(&ebu_lock, flags);

		m->actual_length += t->len;

		if (t->delay.value)
			udelay(t->delay.value);

		spi_flags = 0;

		if (t->cs_change)
			spi_flags |= FLAGS_BEGIN;
	}

	m->status = ret;
	spi_finalize_current_message(master);

	return 0;
}
/*
static int spi_tiny_usb_irqcontrol(struct uio_info *info, s32 irq_on)
{
	struct spi_tiny_usb *priv = (struct spi_tiny_usb *)info->priv;
	dev_dbg(&priv->interface->dev, "spi_tiny_usb_irqcontrol\n");
	return 0;
}
*/
/* ----- end of spi layer ------------------------------------------------ */

/* ----- begin of gpio layer ---------------------------------------------- */

static inline struct spi_tiny_usb *spi_tiny_usb_gc_to_priv(struct gpio_chip *chip)
{
	return container_of(chip, struct spi_tiny_usb, gpio_chip);
}

static int spi_tiny_usb_gpio_input(struct gpio_chip *chip, unsigned offset)
{
	struct spi_tiny_usb *priv = spi_tiny_usb_gc_to_priv(chip);
	int ret;

	if (offset == 0)
		return -ENXIO;

	ret = usb_read(priv, USB_CMD_GPIO_INPUT, 0, offset, 0, 0);
	if (ret < 0)
		return ret;

	return 0;
}

static int spi_tiny_usb_gpio_get(struct gpio_chip *chip, unsigned offset)
{
	struct spi_tiny_usb *priv = spi_tiny_usb_gc_to_priv(chip);
	int ret, retval;

	char *rxbuf = kmalloc(1, GFP_KERNEL);
	if (!rxbuf)
		return -ENOMEM;
	ret = usb_read(priv, USB_CMD_GPIO_GET, 0, offset, rxbuf, 1);
	retval = rxbuf[0] ? 1 : 0;
	kfree(rxbuf);
	if (ret < 0)
		return ret;

	return retval;
}

static int spi_tiny_usb_gpio_output(struct gpio_chip *chip, unsigned offset, int val)
{
	struct spi_tiny_usb *priv = spi_tiny_usb_gc_to_priv(chip);
	int ret;

	ret = usb_read(priv, USB_CMD_GPIO_OUTPUT, 0, offset, 0, 0);
	if (ret < 0)
		return ret;

	return 0;
}

static void spi_tiny_usb_gpio_set(struct gpio_chip *chip, unsigned offset, int val)
{
	struct spi_tiny_usb *priv = spi_tiny_usb_gc_to_priv(chip);

	usb_read(priv, USB_CMD_GPIO_SET, val, offset, 0, 0);
}

/* ----- end of gpio layer ------------------------------------------------ */

/* ----- begin of usb layer ---------------------------------------------- */

static const struct usb_device_id spi_tiny_usb_table[] = {
	{USB_DEVICE(VID, PID)},
	{}
};

MODULE_DEVICE_TABLE(usb, spi_tiny_usb_table);

static void spi_tiny_usb_urb_complete(struct urb *urb)
{
	struct spi_tiny_usb *priv = (struct spi_tiny_usb *)urb->context;
	int ret;

	if (urb->status == 0) {
//		uio_event_notify(priv->uio);
		dev_info(&priv->interface->dev,
			"spi_tiny_usb_urb_complete (%d) %d %d %d %d\n",
			urb->status, priv->urbBuffer[0], priv->urbBuffer[1],
			priv->urbBuffer[2], priv->urbBuffer[3]);
	}

	ret = usb_submit_urb(priv->urb, GFP_KERNEL);
}

static int
usb_read(struct spi_tiny_usb *dev, int cmd, int value, int index, void *data, int len)
{
	/* do control transfer */
	return usb_control_msg(dev->usb_dev, usb_rcvctrlpipe(dev->usb_dev, 0),
			       cmd,
			       USB_TYPE_VENDOR | USB_RECIP_INTERFACE |
			       USB_DIR_IN, value, index, data, len, 2000);
}

static int
usb_write(struct spi_tiny_usb *dev, int cmd, int value, int index, void *data, int len)
{
	/* do control transfer */
	return usb_control_msg(dev->usb_dev, usb_sndctrlpipe(dev->usb_dev, 0),
			       cmd, USB_TYPE_VENDOR | USB_RECIP_INTERFACE,
			       value, index, data, len, 2000);
}

unsigned int GPIO_irqNumber;

static int
_to_irq(struct gpio_chip *chip,
        unsigned offset)
{
//   printk("GPIO to IRQ: 2");
   GPIO_irqNumber = gpio_to_irq(offset);
   printk("GPIO_irqNumber = %d\n", GPIO_irqNumber);
   return GPIO_irqNumber;
}

static int spi_tiny_usb_probe(struct usb_interface *interface,
			      const struct usb_device_id *id)
{
	struct spi_tiny_usb *priv;
	int ret = -ENOMEM;
	u16 version;

	dev_dbg(&interface->dev, "probing usb device\n");

	/* allocate memory for our device state and initialize it */
	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
	if (priv == NULL)
		return -ENOMEM;

	priv->usb_dev = usb_get_dev(interface_to_usbdev(interface));
	priv->interface = interface;

	/* save our data pointer in this interface device */
	usb_set_intfdata(interface, priv);

	version = le16_to_cpu(priv->usb_dev->descriptor.bcdDevice);
	dev_info(&interface->dev,
		 "version %x.%02x found at bus %03d address %03d\n",
		 version >> 8, version & 0xff, priv->usb_dev->bus->busnum,
		 priv->usb_dev->devnum);

	dev_info(&interface->dev, "connected spi-tiny-usb device\n");

	// SPI master
	priv->master = spi_alloc_master(&interface->dev, sizeof(*priv));
	if (!priv->master)
		goto error;
	priv->master->mode_bits = SPI_MODE_0;
	priv->master->flags = 0;
	// priv->master->setup = spi_tiny_usb_setup;
	// priv->master->prepare_transfer_hardware = spi_tiny_usb_prepare_xfer;
	priv->master->transfer_one_message = spi_tiny_usb_xfer_one;
	// priv->master->unprepare_transfer_hardware = spi_tiny_usb_unprepare_xfer;
	priv->master->dev.of_node = interface->dev.of_node;
	priv->master->num_chipselect = 1;
	priv->master->max_speed_hz = 48 * 1000 * 1000 / 2;
	priv->master->min_speed_hz = 48 * 1000 * 1000 / 256;
	// priv->master->dev.platform_data = priv;
	spi_master_set_devdata(priv->master, priv);

	ret = spi_register_master(priv->master);
	if (ret)
		goto error2;

	strcpy(priv->info.modalias, "spidev");
	priv->info.max_speed_hz = 48 * 1000 * 1000 / 2;
	priv->info.chip_select = 0;
	priv->info.mode = SPI_MODE_0;

	priv->info.controller_data = priv;
	priv->spidev = spi_new_device(priv->master, &priv->info);
	if (!priv->spidev)
		goto error2;
	dev_info(&interface->dev, "added new SPI device\n");

/*
	// UIO
	priv->uio = kzalloc(sizeof(struct uio_info), GFP_KERNEL);
	if (!priv->uio)
		goto error2;
	priv->uio->priv = priv;
	priv->uio->name = "spi-tiny-usb";
	priv->uio->version = "1.0.16ton";

	priv->uio->mem[0].size = 0;
	priv->uio->port[0].size = 0;

	priv->uio->irq = UIO_IRQ_CUSTOM; //UIO_IRQ_CUSTOM;
	priv->uio->irq_flags = IRQF_SHARED;
	priv->uio->irqcontrol = spi_tiny_usb_irqcontrol;

	if (uio_register_device(&interface->dev, priv->uio))
		goto error2;
	dev_info(&interface->dev, "registered new UIO device\n");
*/
	// USB interrupt
	priv->urb = usb_alloc_urb(0, GFP_KERNEL);
	if (!priv->urb) {
	    dev_info(&interface->dev, "spi-tiny-usb no usb irq!\n");
		goto error2;
        };
    //16ton


	priv->urbBuffer = kmalloc(64, GFP_KERNEL);

	usb_fill_int_urb(priv->urb, priv->usb_dev,
			 usb_rcvintpipe(priv->usb_dev, 1), priv->urbBuffer, 64,
			 spi_tiny_usb_urb_complete, priv, 10);


	ret = usb_submit_urb(priv->urb, GFP_KERNEL);
	if (ret) {
	    dev_info(&interface->dev, "spi-tiny-usb priv urb gfp_kernel failedr\n");
			goto error2;
	}

	dev_info(&interface->dev, "started USB interrupts handler\n");

	// GPIOs
	memset(&priv->gpio_chip, 0x00, sizeof(priv->gpio_chip));
	priv->gpio_chip.owner = THIS_MODULE;
	priv->gpio_chip.parent = &interface->dev;
	priv->gpio_chip.label = dev_name(priv->gpio_chip.parent);
	priv->gpio_chip.direction_input = spi_tiny_usb_gpio_input;
	priv->gpio_chip.direction_output = spi_tiny_usb_gpio_output;
	priv->gpio_chip.get = spi_tiny_usb_gpio_get;
	priv->gpio_chip.set = spi_tiny_usb_gpio_set;
	priv->gpio_chip.base = -1;
	priv->gpio_chip.ngpio = 2;
	priv->gpio_chip.names = gpio_names;
    priv->gpio_chip.to_irq = f103_gpio_to_irq;   // _to_irq;

	dev_dbg(&interface->dev, "adding GPIO interface\n");
	ret = gpiochip_add(&priv->gpio_chip);
	if (ret) {
		printk(KERN_DEBUG "err %d\n", ret);
		goto error2;
	}

	dev_info(&interface->dev, "added GPIO interface\n");

	dev_info(&interface->dev, "Starting IRQ pin poll\n");

	priv->irq_poll_interval = F103_IRQ_POLL_INTERVAL;
	f103_gpio_irq_probe(priv);

	return 0;

 error2:
	printk(KERN_DEBUG "spi-tiny-usb error2\n");
	spi_master_put(priv->master);

 error:
	printk(KERN_DEBUG "spi-tiny-usb error\n");
	if (priv)
		spi_tiny_usb_free(priv);

	return ret;
}

static void spi_tiny_usb_disconnect(struct usb_interface *interface)
{
	struct spi_tiny_usb *priv = usb_get_intfdata(interface);
//	int i, ret;
    int i;

	for (i = priv->gpio_chip.base; i < priv->gpio_chip.base + priv->gpio_chip.ngpio;
	     i++) {
		gpio_free(i);
	}

	dev_dbg(&interface->dev, "gpiochip_remove\n");
//	ret = gpiochip_remove(&priv->gpio_chip);
    gpiochip_remove(&priv->gpio_chip);

	dev_dbg(&interface->dev, "usb_kill_urb\n");
	usb_kill_urb(priv->urb);

	dev_dbg(&interface->dev, "urbBuffer\n");
	if (priv->urbBuffer)
		kfree(priv->urbBuffer);
/*
	dev_dbg(&interface->dev, "uio\n");
	if (priv->uio) {
		uio_unregister_device(priv->uio);
		kfree(priv->uio);
	}
*/
	f103_gpio_irq_remove(priv);

	dev_dbg(&interface->dev, "usb_free_urb\n");
	if (priv->urb)
		usb_free_urb(priv->urb);

	dev_dbg(&interface->dev, "spi_unregister_master\n");
	spi_unregister_master(priv->master);

	dev_dbg(&interface->dev, "spi_tiny_usb_free\n");
	usb_set_intfdata(interface, NULL);
	spi_tiny_usb_free(priv);

	dev_dbg(&interface->dev, "disconnected\n");
}

static struct usb_driver spi_tiny_usb_driver = {
	.name = "spi-tiny-usb",
	.probe = spi_tiny_usb_probe,
	.disconnect = spi_tiny_usb_disconnect,
	.id_table = spi_tiny_usb_table,
};

module_usb_driver(spi_tiny_usb_driver);

/* ----- end of usb layer ------------------------------------------------ */

MODULE_AUTHOR("Krystian Duzynski <krystian.duzynski@gmail.com>");
MODULE_DESCRIPTION("spi-tiny-usb driver v1.0");
MODULE_LICENSE("GPL");
